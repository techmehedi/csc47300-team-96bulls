{
  "questions": [
    {
      "id": "nc-001",
      "title": "Two Sum",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
      "difficulty": "easy",
      "topic": "arrays",
      "leetcodeNumber": 1,
      "constraints": ["2 ≤ nums.length ≤ 10⁴", "-10⁹ ≤ nums[i] ≤ 10⁹", "-10⁹ ≤ target ≤ 10⁹", "Only one valid answer exists."],
      "examples": [{"input": "nums = [2,7,11,15], target = 9", "output": "[0,1]", "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."}],
      "hints": ["Use a hash map to store visited numbers and their indices", "Check if target - current number exists in the map"],
      "solution": "function twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "tags": ["Array", "Hash Table"]
    },
    {
      "id": "nc-002",
      "title": "Best Time to Buy and Sell Stock",
      "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction.",
      "difficulty": "easy",
      "topic": "arrays",
      "leetcodeNumber": 121,
      "constraints": ["1 ≤ prices.length ≤ 10⁵", "0 ≤ prices[i] ≤ 10⁴"],
      "examples": [{"input": "prices = [7,1,5,3,6,4]", "output": "5", "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."}],
      "hints": ["Keep track of the minimum price seen so far", "Calculate profit if we sell today and update max profit"],
      "solution": "function maxProfit(prices) {\n  let minPrice = prices[0];\n  let maxProfit = 0;\n  for (let i = 1; i < prices.length; i++) {\n    maxProfit = Math.max(maxProfit, prices[i] - minPrice);\n    minPrice = Math.min(minPrice, prices[i]);\n  }\n  return maxProfit;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Dynamic Programming"]
    },
    {
      "id": "nc-003",
      "title": "Contains Duplicate",
      "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
      "difficulty": "easy",
      "topic": "arrays",
      "leetcodeNumber": 217,
      "constraints": ["1 ≤ nums.length ≤ 10⁵", "-10⁹ ≤ nums[i] ≤ 10⁹"],
      "examples": [{"input": "nums = [1,2,3,1]", "output": "true", "explanation": "1 appears twice in the array."}],
      "hints": ["Use a Set to track seen numbers", "If we see a number already in the set, return true"],
      "solution": "function containsDuplicate(nums) {\n  const seen = new Set();\n  for (const num of nums) {\n    if (seen.has(num)) return true;\n    seen.add(num);\n  }\n  return false;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "tags": ["Array", "Hash Table"]
    },
    {
      "id": "nc-004",
      "title": "Product of Array Except Self",
      "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
      "difficulty": "medium",
      "topic": "arrays",
      "leetcodeNumber": 238,
      "constraints": ["2 ≤ nums.length ≤ 10⁵", "-30 ≤ nums[i] ≤ 30", "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."],
      "examples": [{"input": "nums = [1,2,3,4]", "output": "[24,12,8,6]", "explanation": "For index 0: product of all except 1 = 2*3*4 = 24"}],
      "hints": ["Use two passes: left products and right products", "Can you do it in O(1) space?"],
      "solution": "function productExceptSelf(nums) {\n  const result = new Array(nums.length).fill(1);\n  let prefix = 1;\n  for (let i = 0; i < nums.length; i++) {\n    result[i] = prefix;\n    prefix *= nums[i];\n  }\n  let suffix = 1;\n  for (let i = nums.length - 1; i >= 0; i--) {\n    result[i] *= suffix;\n    suffix *= nums[i];\n  }\n  return result;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Prefix Sum"]
    },
    {
      "id": "nc-005",
      "title": "Maximum Subarray",
      "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
      "difficulty": "medium",
      "topic": "arrays",
      "leetcodeNumber": 53,
      "constraints": ["1 ≤ nums.length ≤ 10⁵", "-10⁴ ≤ nums[i] ≤ 10⁴"],
      "examples": [{"input": "nums = [-2,1,-3,4,-1,2,1,-5,4]", "output": "6", "explanation": "[4,-1,2,1] has the largest sum = 6."}],
      "hints": ["Use Kadane's algorithm", "Keep track of current sum and maximum sum"],
      "solution": "function maxSubArray(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Dynamic Programming", "Divide and Conquer"]
    },
    {
      "id": "nc-006",
      "title": "Maximum Product Subarray",
      "description": "Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.",
      "difficulty": "medium",
      "topic": "arrays",
      "leetcodeNumber": 152,
      "constraints": ["1 ≤ nums.length ≤ 2 * 10⁴", "-10 ≤ nums[i] ≤ 10"],
      "examples": [{"input": "nums = [2,3,-2,4]", "output": "6", "explanation": "[2,3] has the largest product = 6."}],
      "hints": ["Track both max and min product (negative numbers flip)", "Reset when current number is better than current product"],
      "solution": "function maxProduct(nums) {\n  let maxSoFar = nums[0];\n  let minSoFar = nums[0];\n  let result = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const temp = maxSoFar;\n    maxSoFar = Math.max(nums[i], nums[i] * maxSoFar, nums[i] * minSoFar);\n    minSoFar = Math.min(nums[i], nums[i] * temp, nums[i] * minSoFar);\n    result = Math.max(result, maxSoFar);\n  }\n  return result;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Dynamic Programming"]
    },
    {
      "id": "nc-007",
      "title": "Find Minimum in Rotated Sorted Array",
      "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Given the sorted rotated array nums of unique elements, return the minimum element of this array.",
      "difficulty": "medium",
      "topic": "arrays",
      "leetcodeNumber": 153,
      "constraints": ["n == nums.length", "1 ≤ n ≤ 5000", "-5000 ≤ nums[i] ≤ 5000", "All integers are unique."],
      "examples": [{"input": "nums = [3,4,5,1,2]", "output": "1", "explanation": "The original array was [1,2,3,4,5] rotated 3 times."}],
      "hints": ["Use binary search", "Check which half contains the minimum"],
      "solution": "function findMin(nums) {\n  let left = 0, right = nums.length - 1;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] > nums[right]) left = mid + 1;\n    else right = mid;\n  }\n  return nums[left];\n}",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Binary Search"]
    },
    {
      "id": "nc-008",
      "title": "Search in Rotated Sorted Array",
      "description": "There is an integer array nums sorted in ascending order (with distinct values). Given the array after possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
      "difficulty": "medium",
      "topic": "arrays",
      "leetcodeNumber": 33,
      "constraints": ["1 ≤ nums.length ≤ 5000", "-10⁴ ≤ nums[i] ≤ 10⁴", "All values are unique.", "-10⁴ ≤ target ≤ 10⁴"],
      "examples": [{"input": "nums = [4,5,6,7,0,1,2], target = 0", "output": "4", "explanation": "0 is at index 4 in the rotated array."}],
      "hints": ["Use binary search", "Determine which half is sorted and check if target is in that range"],
      "solution": "function search(nums, target) {\n  let left = 0, right = nums.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    if (nums[left] <= nums[mid]) {\n      if (target >= nums[left] && target < nums[mid]) right = mid - 1;\n      else left = mid + 1;\n    } else {\n      if (target > nums[mid] && target <= nums[right]) left = mid + 1;\n      else right = mid - 1;\n    }\n  }\n  return -1;\n}",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Binary Search"]
    },
    {
      "id": "nc-009",
      "title": "3Sum",
      "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
      "difficulty": "medium",
      "topic": "arrays",
      "leetcodeNumber": 15,
      "constraints": ["3 ≤ nums.length ≤ 3000", "-10⁵ ≤ nums[i] ≤ 10⁵"],
      "examples": [{"input": "nums = [-1,0,1,2,-1,-4]", "output": "[[-1,-1,2],[-1,0,1]]", "explanation": "These triplets sum to zero."}],
      "hints": ["Sort the array first", "Fix one number and use two pointers for the other two"],
      "solution": "function threeSum(nums) {\n  nums.sort((a, b) => a - b);\n  const result = [];\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n    let left = i + 1, right = nums.length - 1;\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        while (left < right && nums[left] === nums[left + 1]) left++;\n        while (left < right && nums[right] === nums[right - 1]) right--;\n        left++; right--;\n      } else if (sum < 0) left++;\n      else right--;\n    }\n  }\n  return result;\n}",
      "timeComplexity": "O(n²)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Two Pointers", "Sorting"]
    },
    {
      "id": "nc-010",
      "title": "Container With Most Water",
      "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water.",
      "difficulty": "medium",
      "topic": "arrays",
      "leetcodeNumber": 11,
      "constraints": ["n == height.length", "2 ≤ n ≤ 10⁵", "0 ≤ height[i] ≤ 10⁴"],
      "examples": [{"input": "height = [1,8,6,2,5,4,8,3,7]", "output": "49", "explanation": "The max area is between indices 1 and 8 (height 8 and 7)."}],
      "hints": ["Use two pointers from both ends", "Move the pointer with smaller height"],
      "solution": "function maxArea(height) {\n  let left = 0, right = height.length - 1;\n  let maxArea = 0;\n  while (left < right) {\n    const area = Math.min(height[left], height[right]) * (right - left);\n    maxArea = Math.max(maxArea, area);\n    if (height[left] < height[right]) left++;\n    else right--;\n  }\n  return maxArea;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Two Pointers", "Greedy"]
    },
    {
      "id": "nc-011",
      "title": "Valid Anagram",
      "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
      "difficulty": "easy",
      "topic": "strings",
      "leetcodeNumber": 242,
      "constraints": ["1 ≤ s.length, t.length ≤ 5 * 10⁴", "s and t consist of lowercase English letters."],
      "examples": [{"input": "s = \"anagram\", t = \"nagaram\"", "output": "true", "explanation": "t is an anagram of s."}],
      "hints": ["Count character frequencies", "Use a hash map or array of size 26"],
      "solution": "function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  const count = new Array(26).fill(0);\n  for (let i = 0; i < s.length; i++) {\n    count[s.charCodeAt(i) - 97]++;\n    count[t.charCodeAt(i) - 97]--;\n  }\n  return count.every(c => c === 0);\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Hash Table", "String", "Sorting"]
    },
    {
      "id": "nc-012",
      "title": "Group Anagrams",
      "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
      "difficulty": "medium",
      "topic": "strings",
      "leetcodeNumber": 49,
      "constraints": ["1 ≤ strs.length ≤ 10⁴", "0 ≤ strs[i].length ≤ 100", "strs[i] consists of lowercase English letters."],
      "examples": [{"input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]", "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]", "explanation": "Anagrams are grouped together."}],
      "hints": ["Use sorted string as key", "Group strings with same sorted key"],
      "solution": "function groupAnagrams(strs) {\n  const map = new Map();\n  for (const str of strs) {\n    const key = str.split('').sort().join('');\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(str);\n  }\n  return Array.from(map.values());\n}",
      "timeComplexity": "O(n * k log k) where k is max string length",
      "spaceComplexity": "O(n * k)",
      "tags": ["Array", "Hash Table", "String", "Sorting"]
    },
    {
      "id": "nc-013",
      "title": "Valid Parentheses",
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
      "difficulty": "easy",
      "topic": "strings",
      "leetcodeNumber": 20,
      "constraints": ["1 ≤ s.length ≤ 10⁴", "s consists of parentheses only '()[]{}'."],
      "examples": [{"input": "s = \"()\"", "output": "true", "explanation": "The string has valid parentheses."}],
      "hints": ["Use a stack", "Push opening brackets, pop when seeing closing brackets"],
      "solution": "function isValid(s) {\n  const stack = [];\n  const map = { '(': ')', '{': '}', '[': ']' };\n  for (const char of s) {\n    if (map[char]) stack.push(char);\n    else if (stack.length === 0 || map[stack.pop()] !== char) return false;\n  }\n  return stack.length === 0;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "tags": ["String", "Stack"]
    },
    {
      "id": "nc-014",
      "title": "Longest Substring Without Repeating Characters",
      "description": "Given a string s, find the length of the longest substring without repeating characters.",
      "difficulty": "medium",
      "topic": "strings",
      "leetcodeNumber": 3,
      "constraints": ["0 ≤ s.length ≤ 5 * 10⁴", "s consists of English letters, digits, symbols and spaces."],
      "examples": [{"input": "s = \"abcabcbb\"", "output": "3", "explanation": "The longest substring is \"abc\" with length 3."}],
      "hints": ["Use sliding window with hash map", "Move left pointer when duplicate found"],
      "solution": "function lengthOfLongestSubstring(s) {\n  const map = new Map();\n  let maxLen = 0, left = 0;\n  for (let right = 0; right < s.length; right++) {\n    if (map.has(s[right])) left = Math.max(left, map.get(s[right]) + 1);\n    map.set(s[right], right);\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  return maxLen;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(min(n, m)) where m is charset size",
      "tags": ["Hash Table", "String", "Sliding Window"]
    },
    {
      "id": "nc-015",
      "title": "Longest Repeating Character Replacement",
      "description": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English letter. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations.",
      "difficulty": "medium",
      "topic": "strings",
      "leetcodeNumber": 424,
      "constraints": ["1 ≤ s.length ≤ 10⁵", "s consists of only uppercase English letters.", "0 ≤ k ≤ s.length"],
      "examples": [{"input": "s = \"AABABBA\", k = 1", "output": "4", "explanation": "Replace one 'A' with 'B' or vice versa to get AAAA or BBBB."}],
      "hints": ["Use sliding window", "Track max frequency in current window"],
      "solution": "function characterReplacement(s, k) {\n  const count = new Map();\n  let maxFreq = 0, maxLen = 0, left = 0;\n  for (let right = 0; right < s.length; right++) {\n    count.set(s[right], (count.get(s[right]) || 0) + 1);\n    maxFreq = Math.max(maxFreq, count.get(s[right]));\n    if (right - left + 1 - maxFreq > k) {\n      count.set(s[left], count.get(s[left]) - 1);\n      left++;\n    }\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  return maxLen;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Hash Table", "String", "Sliding Window"]
    },
    {
      "id": "nc-016",
      "title": "Minimum Window Substring",
      "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such window, return the empty string \"\".",
      "difficulty": "hard",
      "topic": "strings",
      "leetcodeNumber": 76,
      "constraints": ["m == s.length", "n == t.length", "1 ≤ m, n ≤ 10⁵", "s and t consist of uppercase and lowercase English letters."],
      "examples": [{"input": "s = \"ADOBECODEBANC\", t = \"ABC\"", "output": "BANC", "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."}],
      "hints": ["Use sliding window with two pointers", "Expand right until valid, then shrink left"],
      "solution": "function minWindow(s, t) {\n  const need = new Map();\n  for (const char of t) need.set(char, (need.get(char) || 0) + 1);\n  let needCount = t.length, left = 0, minLen = Infinity, minStart = 0;\n  for (let right = 0; right < s.length; right++) {\n    if (need.has(s[right]) && need.get(s[right]) > 0) needCount--;\n    if (need.has(s[right])) need.set(s[right], need.get(s[right]) - 1);\n    while (needCount === 0) {\n      if (right - left + 1 < minLen) {\n        minLen = right - left + 1;\n        minStart = left;\n      }\n      if (need.has(s[left]) && need.get(s[left]) === 0) needCount++;\n      if (need.has(s[left])) need.set(s[left], need.get(s[left]) + 1);\n      left++;\n    }\n  }\n  return minLen === Infinity ? '' : s.substr(minStart, minLen);\n}",
      "timeComplexity": "O(m + n)",
      "spaceComplexity": "O(m + n)",
      "tags": ["Hash Table", "String", "Sliding Window"]
    },
    {
      "id": "nc-017",
      "title": "Climbing Stairs",
      "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "difficulty": "easy",
      "topic": "dynamic-programming",
      "leetcodeNumber": 70,
      "constraints": ["1 ≤ n ≤ 45"],
      "examples": [{"input": "n = 2", "output": "2", "explanation": "Two ways: 1+1 or 2."}],
      "hints": ["This is Fibonacci sequence", "Use DP or just two variables"],
      "solution": "function climbStairs(n) {\n  if (n <= 2) return n;\n  let first = 1, second = 2;\n  for (let i = 3; i <= n; i++) {\n    const third = first + second;\n    first = second;\n    second = third;\n  }\n  return second;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Math", "Dynamic Programming", "Memoization"]
    },
    {
      "id": "nc-018",
      "title": "House Robber",
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. If two adjacent houses are broken into on the same night, the police will be notified. Determine the maximum amount of money you can rob tonight without alerting the police.",
      "difficulty": "medium",
      "topic": "dynamic-programming",
      "leetcodeNumber": 198,
      "constraints": ["1 ≤ nums.length ≤ 100", "0 ≤ nums[i] ≤ 400"],
      "examples": [{"input": "nums = [2,7,9,3,1]", "output": "12", "explanation": "Rob houses 1 and 3 (2 + 9 = 11) or house 2 (7). Actually 2 + 9 = 11, wait recalc: houses 0 and 2 give 2+9=11, or houses 1 and 3 give 7+3=10, or house 1 alone gives 7... Actually optimal is 2+9+1=12"}],
      "hints": ["DP: rob current + skip next, or skip current", "Keep track of max money with/without robbing current"],
      "solution": "function rob(nums) {\n  let rob1 = 0, rob2 = 0;\n  for (const num of nums) {\n    const temp = Math.max(rob1 + num, rob2);\n    rob1 = rob2;\n    rob2 = temp;\n  }\n  return rob2;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Dynamic Programming"]
    },
    {
      "id": "nc-019",
      "title": "House Robber II",
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. Determine the maximum amount of money you can rob tonight without alerting the police.",
      "difficulty": "medium",
      "topic": "dynamic-programming",
      "leetcodeNumber": 198,
      "constraints": ["1 ≤ nums.length ≤ 100", "0 ≤ nums[i] ≤ 1000"],
      "examples": [{"input": "nums = [2,3,2]", "output": "3", "explanation": "Cannot rob house 0 and house 2 as they are adjacent. Rob house 1."}],
      "hints": ["Run House Robber twice: exclude first, exclude last", "Take maximum of both"],
      "solution": "function rob(nums) {\n  if (nums.length === 1) return nums[0];\n  return Math.max(robHelper(nums.slice(1)), robHelper(nums.slice(0, -1)));\n}\nfunction robHelper(nums) {\n  let rob1 = 0, rob2 = 0;\n  for (const num of nums) {\n    const temp = Math.max(rob1 + num, rob2);\n    rob1 = rob2;\n    rob2 = temp;\n  }\n  return rob2;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Dynamic Programming"]
    },
    {
      "id": "nc-020",
      "title": "Longest Palindromic Substring",
      "description": "Given a string s, return the longest palindromic substring in s.",
      "difficulty": "medium",
      "topic": "strings",
      "leetcodeNumber": 5,
      "constraints": ["1 ≤ s.length ≤ 1000", "s consist of only digits and English letters."],
      "examples": [{"input": "s = \"babad\"", "output": "bab", "explanation": "\"aba\" is also a valid answer."}],
      "hints": ["Expand around centers", "Check odd and even length palindromes"],
      "solution": "function longestPalindrome(s) {\n  let start = 0, maxLen = 0;\n  for (let i = 0; i < s.length; i++) {\n    const len1 = expandAroundCenter(s, i, i);\n    const len2 = expandAroundCenter(s, i, i + 1);\n    const len = Math.max(len1, len2);\n    if (len > maxLen) {\n      maxLen = len;\n      start = i - Math.floor((len - 1) / 2);\n    }\n  }\n  return s.substr(start, maxLen);\n}\nfunction expandAroundCenter(s, left, right) {\n  while (left >= 0 && right < s.length && s[left] === s[right]) {\n    left--; right++;\n  }\n  return right - left - 1;\n}",
      "timeComplexity": "O(n²)",
      "spaceComplexity": "O(1)",
      "tags": ["String", "Dynamic Programming"]
    },
    {
      "id": "nc-021",
      "title": "Palindromic Substrings",
      "description": "Given a string s, return the number of palindromic substrings in it.",
      "difficulty": "medium",
      "topic": "strings",
      "leetcodeNumber": 647,
      "constraints": ["1 ≤ s.length ≤ 1000", "s consists of lowercase English letters."],
      "examples": [{"input": "s = \"abc\"", "output": "3", "explanation": "Three palindromic strings: \"a\", \"b\", \"c\"."}],
      "hints": ["Expand around centers", "Count all palindromes from each center"],
      "solution": "function countSubstrings(s) {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    count += expandAroundCenter(s, i, i);\n    count += expandAroundCenter(s, i, i + 1);\n  }\n  return count;\n}\nfunction expandAroundCenter(s, left, right) {\n  let count = 0;\n  while (left >= 0 && right < s.length && s[left] === s[right]) {\n    count++;\n    left--; right++;\n  }\n  return count;\n}",
      "timeComplexity": "O(n²)",
      "spaceComplexity": "O(1)",
      "tags": ["String", "Dynamic Programming"]
    },
    {
      "id": "nc-022",
      "title": "Decode Ways",
      "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> \"1\", 'B' -> \"2\", ..., 'Z' -> \"26\". Given a string s containing only digits, return the number of ways to decode it.",
      "difficulty": "medium",
      "topic": "dynamic-programming",
      "leetcodeNumber": 91,
      "constraints": ["1 ≤ s.length ≤ 100", "s contains only digits and may contain leading zero(s)."],
      "examples": [{"input": "s = \"12\"", "output": "2", "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)."}],
      "hints": ["DP: ways to decode ending at index i", "Check if current digit valid, and if two digits valid"],
      "solution": "function numDecodings(s) {\n  const dp = { [s.length]: 1 };\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === '0') dp[i] = 0;\n    else {\n      dp[i] = dp[i + 1];\n      if (i + 1 < s.length && parseInt(s.substr(i, 2)) <= 26) dp[i] += dp[i + 2];\n    }\n  }\n  return dp[0];\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "tags": ["String", "Dynamic Programming"]
    },
    {
      "id": "nc-023",
      "title": "Coin Change",
      "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
      "difficulty": "medium",
      "topic": "dynamic-programming",
      "leetcodeNumber": 322,
      "constraints": ["1 ≤ coins.length ≤ 12", "1 ≤ coins[i] ≤ 2³¹ - 1", "0 ≤ amount ≤ 10⁴"],
      "examples": [{"input": "coins = [1,2,5], amount = 11", "output": "3", "explanation": "11 = 5 + 5 + 1"}],
      "hints": ["DP: min coins to make amount i", "Try each coin and take minimum"],
      "solution": "function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (i >= coin) dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}",
      "timeComplexity": "O(amount * coins.length)",
      "spaceComplexity": "O(amount)",
      "tags": ["Array", "Dynamic Programming", "Breadth-First Search"]
    },
    {
      "id": "nc-024",
      "title": "Maximum Product Subarray",
      "description": "Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.",
      "difficulty": "medium",
      "topic": "arrays",
      "leetcodeNumber": 152,
      "constraints": ["1 ≤ nums.length ≤ 2 * 10⁴", "-10 ≤ nums[i] ≤ 10"],
      "examples": [{"input": "nums = [2,3,-2,4]", "output": "6", "explanation": "[2,3] has the largest product = 6."}],
      "hints": ["Track both max and min product", "Negative numbers flip min/max"],
      "solution": "function maxProduct(nums) {\n  let maxSoFar = nums[0], minSoFar = nums[0], result = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const temp = maxSoFar;\n    maxSoFar = Math.max(nums[i], nums[i] * maxSoFar, nums[i] * minSoFar);\n    minSoFar = Math.min(nums[i], nums[i] * temp, nums[i] * minSoFar);\n    result = Math.max(result, maxSoFar);\n  }\n  return result;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["Array", "Dynamic Programming"]
    },
    {
      "id": "nc-025",
      "title": "Word Break",
      "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.",
      "difficulty": "medium",
      "topic": "dynamic-programming",
      "leetcodeNumber": 139,
      "constraints": ["1 ≤ s.length ≤ 300", "1 ≤ wordDict.length ≤ 1000", "1 ≤ wordDict[i].length ≤ 20"],
      "examples": [{"input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]", "output": "true", "explanation": "Return true because \"leetcode\" can be segmented as \"leet code\"."}],
      "hints": ["DP: can we break s[0:i]?", "Try all word endings at position i"],
      "solution": "function wordBreak(s, wordDict) {\n  const dp = new Array(s.length + 1).fill(false);\n  dp[0] = true;\n  const wordSet = new Set(wordDict);\n  for (let i = 1; i <= s.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (dp[j] && wordSet.has(s.substring(j, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n  return dp[s.length];\n}",
      "timeComplexity": "O(n² * m) where m is avg word length",
      "spaceComplexity": "O(n)",
      "tags": ["Hash Table", "String", "Dynamic Programming", "Trie", "Memoization"]
    },
    {
      "id": "nc-026",
      "title": "Longest Common Subsequence",
      "description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.",
      "difficulty": "medium",
      "topic": "dynamic-programming",
      "leetcodeNumber": 1143,
      "constraints": ["1 ≤ text1.length, text2.length ≤ 1000", "text1 and text2 consist of only lowercase English characters."],
      "examples": [{"input": "text1 = \"abcde\", text2 = \"ace\"", "output": "3", "explanation": "The longest common subsequence is \"ace\" with length 3."}],
      "hints": ["2D DP: dp[i][j] = LCS of text1[0:i] and text2[0:j]", "If chars match: 1 + dp[i-1][j-1], else max(dp[i-1][j], dp[i][j-1])"],
      "solution": "function longestCommonSubsequence(text1, text2) {\n  const m = text1.length, n = text2.length;\n  const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i-1] === text2[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\n      else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n    }\n  }\n  return dp[m][n];\n}",
      "timeComplexity": "O(m * n)",
      "spaceComplexity": "O(m * n)",
      "tags": ["String", "Dynamic Programming"]
    },
    {
      "id": "nc-027",
      "title": "Unique Paths",
      "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (0, 0). The robot tries to move to the bottom-right corner (m - 1, n - 1). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
      "difficulty": "medium",
      "topic": "dynamic-programming",
      "leetcodeNumber": 62,
      "constraints": ["1 ≤ m, n ≤ 100"],
      "examples": [{"input": "m = 3, n = 7", "output": "28", "explanation": "There are 28 unique paths from top-left to bottom-right."}],
      "hints": ["DP: paths[i][j] = paths[i-1][j] + paths[i][j-1]", "Can optimize to O(n) space"],
      "solution": "function uniquePaths(m, n) {\n  const dp = Array(m).fill(1);\n  for (let j = 1; j < n; j++) {\n    for (let i = 1; i < m; i++) {\n      dp[i] += dp[i - 1];\n    }\n  }\n  return dp[m - 1];\n}",
      "timeComplexity": "O(m * n)",
      "spaceComplexity": "O(m)",
      "tags": ["Math", "Dynamic Programming", "Combinatorics"]
    },
    {
      "id": "nc-028",
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
      "difficulty": "medium",
      "topic": "trees",
      "leetcodeNumber": 105,
      "constraints": ["1 ≤ preorder.length ≤ 3000", "inorder.length == preorder.length", "-3000 ≤ preorder[i], inorder[i] ≤ 3000"],
      "examples": [{"input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]", "output": "[3,9,20,null,null,15,7]", "explanation": "The binary tree is constructed from the traversals."}],
      "hints": ["First element of preorder is root", "Find root in inorder to split left/right subtrees", "Recursively build left and right"],
      "solution": "function buildTree(preorder, inorder) {\n  if (!preorder.length || !inorder.length) return null;\n  const root = new TreeNode(preorder[0]);\n  const mid = inorder.indexOf(preorder[0]);\n  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n  return root;\n}",
      "timeComplexity": "O(n²)",
      "spaceComplexity": "O(n)",
      "tags": ["Array", "Hash Table", "Divide and Conquer", "Tree", "Binary Tree"]
    },
    {
      "id": "nc-029",
      "title": "Maximum Depth of Binary Tree",
      "description": "Given the root of a binary tree, return its maximum depth.",
      "difficulty": "easy",
      "topic": "trees",
      "leetcodeNumber": 104,
      "constraints": ["The number of nodes in the tree is in the range [0, 10⁴].", "-100 ≤ Node.val ≤ 100"],
      "examples": [{"input": "root = [3,9,20,null,null,15,7]", "output": "3", "explanation": "The maximum depth is 3."}],
      "hints": ["Recursive: 1 + max(left depth, right depth)", "Base case: null node returns 0"],
      "solution": "function maxDepth(root) {\n  if (!root) return 0;\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h) where h is height",
      "tags": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"]
    },
    {
      "id": "nc-030",
      "title": "Same Tree",
      "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.",
      "difficulty": "easy",
      "topic": "trees",
      "leetcodeNumber": 100,
      "constraints": ["The number of nodes in both trees is in the range [0, 100].", "-10⁴ ≤ Node.val ≤ 10⁴"],
      "examples": [{"input": "p = [1,2,3], q = [1,2,3]", "output": "true", "explanation": "Both trees are identical."}],
      "hints": ["Recursive: check if values match and both subtrees are same", "Base case: both null is true, one null is false"],
      "solution": "function isSameTree(p, q) {\n  if (!p && !q) return true;\n  if (!p || !q) return false;\n  return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "tags": ["Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "id": "nc-031",
      "title": "Invert Binary Tree",
      "description": "Given the root of a binary tree, invert the tree, and return its root.",
      "difficulty": "easy",
      "topic": "trees",
      "leetcodeNumber": 226,
      "constraints": ["The number of nodes in the tree is in the range [0, 100].", "-100 ≤ Node.val ≤ 100"],
      "examples": [{"input": "root = [4,2,7,1,3,6,9]", "output": "[4,7,2,9,6,3,1]", "explanation": "The tree is inverted."}],
      "hints": ["Recursive: swap left and right, then invert both subtrees", "Iterative: use queue/stack"],
      "solution": "function invertTree(root) {\n  if (!root) return null;\n  [root.left, root.right] = [invertTree(root.right), invertTree(root.left)];\n  return root;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "tags": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"]
    },
    {
      "id": "nc-032",
      "title": "Binary Tree Maximum Path Sum",
      "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. The path sum of a path is the sum of the node values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.",
      "difficulty": "hard",
      "topic": "trees",
      "leetcodeNumber": 124,
      "constraints": ["The number of nodes in the tree is in the range [1, 3 * 10⁴].", "-1000 ≤ Node.val ≤ 1000"],
      "examples": [{"input": "root = [1,2,3]", "output": "6", "explanation": "The path 2 -> 1 -> 3 has maximum sum 6."}],
      "hints": ["DFS: return max path ending at current node", "Track global max: current + left + right"],
      "solution": "function maxPathSum(root) {\n  let maxSum = -Infinity;\n  function dfs(node) {\n    if (!node) return 0;\n    const left = Math.max(0, dfs(node.left));\n    const right = Math.max(0, dfs(node.right));\n    maxSum = Math.max(maxSum, node.val + left + right);\n    return node.val + Math.max(left, right);\n  }\n  dfs(root);\n  return maxSum;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "tags": ["Dynamic Programming", "Tree", "Depth-First Search", "Binary Tree"]
    },
    {
      "id": "nc-033",
      "title": "Binary Tree Level Order Traversal",
      "description": "Given the root of a binary tree, return the level order traversal of its nodes' values.",
      "difficulty": "medium",
      "topic": "trees",
      "leetcodeNumber": 102,
      "constraints": ["The number of nodes in the tree is in the range [0, 2000].", "-1000 ≤ Node.val ≤ 1000"],
      "examples": [{"input": "root = [3,9,20,null,null,15,7]", "output": "[[3],[9,20],[15,7]]", "explanation": "Level order traversal."}],
      "hints": ["Use BFS with queue", "Process all nodes at current level before moving to next"],
      "solution": "function levelOrder(root) {\n  if (!root) return [];\n  const result = [], queue = [root];\n  while (queue.length) {\n    const level = [], size = queue.length;\n    for (let i = 0; i < size; i++) {\n      const node = queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    result.push(level);\n  }\n  return result;\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "tags": ["Tree", "Breadth-First Search", "Binary Tree"]
    },
    {
      "id": "nc-034",
      "title": "Serialize and Deserialize Binary Tree",
      "description": "Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work.",
      "difficulty": "hard",
      "topic": "trees",
      "leetcodeNumber": 297,
      "constraints": ["The number of nodes in the tree is in the range [0, 10⁴].", "-1000 ≤ Node.val ≤ 1000"],
      "examples": [{"input": "root = [1,2,3,null,null,4,5]", "output": "[1,2,3,null,null,4,5]", "explanation": "Serialized and deserialized tree."}],
      "hints": ["Preorder traversal with null markers", "Use queue for deserialization"],
      "solution": "function serialize(root) {\n  const result = [];\n  function dfs(node) {\n    if (!node) { result.push('null'); return; }\n    result.push(node.val.toString());\n    dfs(node.left);\n    dfs(node.right);\n  }\n  dfs(root);\n  return result.join(',');\n}\nfunction deserialize(data) {\n  const values = data.split(',');\n  let index = 0;\n  function dfs() {\n    if (values[index] === 'null') { index++; return null; }\n    const node = new TreeNode(parseInt(values[index++]));\n    node.left = dfs();\n    node.right = dfs();\n    return node;\n  }\n  return dfs();\n}",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "tags": ["String", "Tree", "Depth-First Search", "Breadth-First Search", "Design", "Binary Tree"]
    },
    {
      "id": "nc-035",
      "title": "Subtree of Another Tree",
      "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.",
      "difficulty": "easy",
      "topic": "trees",
      "leetcodeNumber": 100,
      "constraints": ["The number of nodes in the root tree is in the range [1, 2000].", "The number of nodes in the subRoot tree is in the range [1, 1000].", "-10⁴ ≤ root.val ≤ 10⁴", "-10⁴ ≤ subRoot.val ≤ 10⁴"],
      "examples": [{"input": "root = [3,4,5,1,2], subRoot = [4,1,2]", "output": "true", "explanation": "subRoot is a subtree of root."}],
      "hints": ["For each node in root, check if subtree starting there matches subRoot", "Use helper to check if two trees are identical"],
      "solution": "function isSubtree(root, subRoot) {\n  if (!root) return false;\n  if (isSameTree(root, subRoot)) return true;\n  return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\nfunction isSameTree(p, q) {\n  if (!p && !q) return true;\n  if (!p || !q) return false;\n  return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}",
      "timeComplexity": "O(m * n)",
      "spaceComplexity": "O(h)",
      "tags": ["Tree", "Depth-First Search", "String Matching", "Binary Tree", "Hash Function"]
    },
    {
      "id": "nc-036",
      "title": "Number of Islands",
      "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.",
      "difficulty": "medium",
      "topic": "graphs",
      "leetcodeNumber": 200,
      "constraints": ["m == grid.length", "n == grid[i].length", "1 ≤ m, n ≤ 300", "grid[i][j] is '0' or '1'."],
      "examples": [{"input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]", "output": "1", "explanation": "There is one island in the grid."}],
      "hints": ["Use DFS or BFS to mark all connected land cells", "Count number of DFS/BFS starts"],
      "solution": "function numIslands(grid) {\n  let count = 0;\n  function dfs(i, j) {\n    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return;\n    grid[i][j] = '0';\n    dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1);\n  }\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] === '1') { count++; dfs(i, j); }\n    }\n  }\n  return count;\n}",
      "timeComplexity": "O(m * n)",
      "spaceComplexity": "O(m * n)",
      "tags": ["Array", "Depth-First Search", "Breadth-First Search", "Union Find", "Matrix"]
    },
    {
      "id": "nc-037",
      "title": "Clone Graph",
      "description": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph.",
      "difficulty": "medium",
      "topic": "graphs",
      "leetcodeNumber": 133,
      "constraints": ["The number of nodes in the graph is in the range [0, 100].", "1 ≤ Node.val ≤ 100", "Node.val is unique for each node."],
      "examples": [{"input": "adjList = [[2,4],[1,3],[2,4],[1,3]]", "output": "[[2,4],[1,3],[2,4],[1,3]]", "explanation": "The graph is cloned."}],
      "hints": ["Use DFS with hash map to track cloned nodes", "Clone node and recursively clone neighbors"],
      "solution": "function cloneGraph(node) {\n  if (!node) return null;\n  const map = new Map();\n  function dfs(original) {\n    if (map.has(original)) return map.get(original);\n    const clone = new Node(original.val);\n    map.set(original, clone);\n    for (const neighbor of original.neighbors) {\n      clone.neighbors.push(dfs(neighbor));\n    }\n    return clone;\n  }\n  return dfs(node);\n}",
      "timeComplexity": "O(V + E)",
      "spaceComplexity": "O(V)",
      "tags": ["Hash Table", "Depth-First Search", "Breadth-First Search", "Graph"]
    },
    {
      "id": "nc-038",
      "title": "Pacific Atlantic Water Flow",
      "description": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. Water can only flow in four directions: up, down, left, and right. Water flows from a cell to an adjacent one with an equal or lower height. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from the cell (ri, ci) to both the Pacific and Atlantic oceans.",
      "difficulty": "medium",
      "topic": "graphs",
      "leetcodeNumber": 417,
      "constraints": ["m == heights.length", "n == heights[i].length", "1 ≤ m, n ≤ 200", "0 ≤ heights[i][j] ≤ 10⁵"],
      "examples": [{"input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]", "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]", "explanation": "These cells can flow to both oceans."}],
      "hints": ["DFS from Pacific edges and Atlantic edges separately", "Find intersection of cells reachable from both"],
      "solution": "function pacificAtlantic(heights) {\n  const m = heights.length, n = heights[0].length;\n  const pacific = Array(m).fill(0).map(() => Array(n).fill(false));\n  const atlantic = Array(m).fill(0).map(() => Array(n).fill(false));\n  function dfs(i, j, ocean) {\n    ocean[i][j] = true;\n    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];\n    for (const [di, dj] of dirs) {\n      const ni = i + di, nj = j + dj;\n      if (ni >= 0 && ni < m && nj >= 0 && nj < n && !ocean[ni][nj] && heights[ni][nj] >= heights[i][j]) {\n        dfs(ni, nj, ocean);\n      }\n    }\n  }\n  for (let i = 0; i < m; i++) { dfs(i, 0, pacific); dfs(i, n - 1, atlantic); }\n  for (let j = 0; j < n; j++) { dfs(0, j, pacific); dfs(m - 1, j, atlantic); }\n  const result = [];\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (pacific[i][j] && atlantic[i][j]) result.push([i, j]);\n    }\n  }\n  return result;\n}",
      "timeComplexity": "O(m * n)",
      "spaceComplexity": "O(m * n)",
      "tags": ["Array", "Depth-First Search", "Breadth-First Search", "Matrix"]
    }
  ]
}

